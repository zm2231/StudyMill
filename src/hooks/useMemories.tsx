'use client';\n\nimport { useState, useEffect } from 'react';\nimport { useApi } from '@/lib/api';\n\nexport interface Memory {\n  id: string;\n  userId: string;\n  content: string;\n  sourceType: 'manual' | 'document' | 'web' | 'conversation' | 'audio';\n  sourceId?: string;\n  containerTags: string[];\n  metadata: Record<string, any>;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface MemorySearchResult {\n  id: string;\n  score: number;\n  content: string;\n  sourceType: string;\n  containerTags: string[];\n  metadata: Record<string, any>;\n}\n\nexport interface MemorySearchFilters {\n  source_type?: string;\n  container_tags?: string[];\n}\n\nexport interface CreateMemoryData {\n  content: string;\n  source_type: 'manual' | 'document' | 'web' | 'conversation' | 'audio';\n  source_id?: string;\n  container_tags?: string[];\n  metadata?: Record<string, any>;\n}\n\nexport function useMemories() {\n  const [memories, setMemories] = useState<Memory[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const api = useApi();\n\n  // Fetch all memories\n  const fetchMemories = async (filters?: {\n    source_type?: string;\n    container_tags?: string;\n    limit?: number;\n    offset?: number;\n  }) => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const params = new URLSearchParams();\n      if (filters?.source_type) params.append('source_type', filters.source_type);\n      if (filters?.container_tags) params.append('container_tags', filters.container_tags);\n      if (filters?.limit) params.append('limit', filters.limit.toString());\n      if (filters?.offset) params.append('offset', filters.offset.toString());\n      \n      const queryString = params.toString();\n      const url = `/api/v1/memories${queryString ? `?${queryString}` : ''}`;\n      \n      const response = await api.request<{ memories: Memory[]; total: number }>(url);\n      setMemories(response.memories);\n      return response;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch memories';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Get a specific memory\n  const getMemory = async (id: string): Promise<Memory> => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await api.request<{ memory: Memory }>(`/api/v1/memories/${id}`);\n      return response.memory;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch memory';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Create a new memory\n  const createMemory = async (data: CreateMemoryData): Promise<Memory> => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await api.request<{ memory: Memory }>('/api/v1/memories', {\n        method: 'POST',\n        body: JSON.stringify(data),\n      });\n      \n      // Add the new memory to the local state\n      setMemories(prev => [response.memory, ...prev]);\n      \n      return response.memory;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to create memory';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Update a memory\n  const updateMemory = async (id: string, data: Partial<CreateMemoryData>): Promise<Memory> => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await api.request<{ memory: Memory }>(`/api/v1/memories/${id}`, {\n        method: 'PUT',\n        body: JSON.stringify(data),\n      });\n      \n      // Update the memory in local state\n      setMemories(prev => prev.map(m => m.id === id ? response.memory : m));\n      \n      return response.memory;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to update memory';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Delete a memory\n  const deleteMemory = async (id: string): Promise<void> => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      await api.request<{ success: boolean }>(`/api/v1/memories/${id}`, {\n        method: 'DELETE',\n      });\n      \n      // Remove the memory from local state\n      setMemories(prev => prev.filter(m => m.id !== id));\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to delete memory';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Search memories\n  const searchMemories = async (\n    query: string,\n    filters?: MemorySearchFilters,\n    limit?: number\n  ): Promise<MemorySearchResult[]> => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await api.request<{ results: MemorySearchResult[] }>('/api/v1/memories/search', {\n        method: 'POST',\n        body: JSON.stringify({\n          query,\n          filters: filters || {},\n          limit: limit || 10,\n        }),\n      });\n      \n      return response.results;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to search memories';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Import memories from a document\n  const importFromDocument = async (\n    documentId: string,\n    containerTags?: string[]\n  ): Promise<Memory[]> => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await api.request<{ memories: Memory[]; imported: number }>('/api/v1/memories/import/document', {\n        method: 'POST',\n        body: JSON.stringify({\n          document_id: documentId,\n          container_tags: containerTags || [],\n        }),\n      });\n      \n      // Add imported memories to local state\n      setMemories(prev => [...response.memories, ...prev]);\n      \n      return response.memories;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to import memories';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Get memory relations\n  const getMemoryRelations = async (id: string, limit?: number) => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const params = limit ? `?limit=${limit}` : '';\n      const response = await api.request<{ relations: any[] }>(`/api/v1/memories/${id}/relations${params}`);\n      return response.relations;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch memory relations';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Get unique container tags (courses)\n  const getContainerTags = (): string[] => {\n    const allTags = memories.flatMap(memory => memory.containerTags);\n    return Array.from(new Set(allTags)).sort();\n  };\n\n  // Get memories by container tag (course)\n  const getMemoriesByTag = (tag: string): Memory[] => {\n    return memories.filter(memory => memory.containerTags.includes(tag));\n  };\n\n  // Get memory statistics\n  const getStats = () => {\n    const totalMemories = memories.length;\n    const bySourceType = memories.reduce((acc, memory) => {\n      acc[memory.sourceType] = (acc[memory.sourceType] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n    \n    const byContainerTag = memories.reduce((acc, memory) => {\n      memory.containerTags.forEach(tag => {\n        acc[tag] = (acc[tag] || 0) + 1;\n      });\n      return acc;\n    }, {} as Record<string, number>);\n    \n    return {\n      total: totalMemories,\n      bySourceType,\n      byContainerTag,\n    };\n  };\n\n  return {\n    memories,\n    loading,\n    error,\n    fetchMemories,\n    getMemory,\n    createMemory,\n    updateMemory,\n    deleteMemory,\n    searchMemories,\n    importFromDocument,\n    getMemoryRelations,\n    getContainerTags,\n    getMemoriesByTag,\n    getStats,\n  };\n}\n\n// Hook for managing a single memory\nexport function useMemory(id?: string) {\n  const [memory, setMemory] = useState<Memory | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const api = useApi();\n\n  useEffect(() => {\n    if (id) {\n      fetchMemory(id);\n    }\n  }, [id]);\n\n  const fetchMemory = async (memoryId: string) => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await api.request<{ memory: Memory }>(`/api/v1/memories/${memoryId}`);\n      setMemory(response.memory);\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch memory';\n      setError(errorMessage);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return {\n    memory,\n    loading,\n    error,\n    refetch: () => id && fetchMemory(id),\n  };\n}"